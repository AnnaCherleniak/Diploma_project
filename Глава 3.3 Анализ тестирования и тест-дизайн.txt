3.3 Анализ тестирования и тест-дизайн

Анализ тестирования.
Представим, что мы тестируем интернет-магазин. Исходя из требований (базиса тестирования) мы понимаем, что именно нам нужно протестировать. Например, нам надо проверить, что пользователь может зарегистрироваться, войти в приложение, найти там товар, добавить его в корзину, после чего оплатить и получить.
Дальше, в рамках анализа тестирования, нам нужно определить следующие вещи:
1. Уровни тестирования — на сколько глубоко нам нужно протестировать каждое требование (Компонентное, интеграционное и системное тестирование);
2. Уровень детализации и качества наших требований;
3. Связи между требованиями;
4. Сложность нашего приложения;
5. Продуктовые и проектные риски;
6. Жизненный цикл разработки ПО и его длительность;
7. Инструменты по управлению тестированием (Test management system);
8. Опыт и постоянность команды;
9. Доступность для консультации других участников проекта.
Исходя из вышеописанных моментов, мы можем принять решение о том, на сколько глубоко нам надо тестировать конкретное требование и какой вид документации лучше всего применить.
Например, если проект представляет собой сложную систему, с высокими рисками и нестабильной командой — то необходимо будет выбрать наиболее подробный вид документации, скажем тест-кейс. Из-за высоких рисков и сложности тесты необходимо будет проектировать на всех уровнях и максимально детально. Благодаря максимально проработанным тестам новым членам команды будет намного проще войти в проект нежели при использовании менее детальной документации.
Главный принцип для выбора документации — это окупаемость этой самой документации.
Я думаю логика понята. Чем сложнее, рискованней, дольше и стабильней наш проект, тем глубже и детальнее нужно прорабатывать тесты.
Для простого проекта, с невысокими рисками и продолжительность, с не совсем стабильными требованиями и стабильной командой можно использовать высокоуровневую тестовую документацию, например чек-листы. В противном случае мы рискуем потратить большую часть времени на тест дизайн и поддержку документации, а не на выполнение тестов.
Иногда для проверки разных требований может применяться тестовая документация разных уровней.
Например, для сложного и рискового функционала — детальные тест кейсы, а для простого и нерискового — либо чек-лист.
Зачем делать анализ тестирования?
Можно выделить 2 больших достоинства анализа тестирования:
1. Создание ясности и гибкости в других активностях тестирования благодаря определению точных целей тестов. Мы знаем что именно и на сколько глубоко нужно тестировать.
2. Предотвращение дефектов: именно на этапе анализа тестирования проводится верификация и статическое тестирование.
После определения того, что мы будем делать, можно приступить к этапу создания тестов.

Проектирование тестов и Тест-дизайн.
Разработка тест-кейсов — важный этап в жизненном цикле тестирования. От того, насколько правильно написаны тест-кейсы, может зависеть весь процесс тестирования. Создавать эффективные тест-кейсы позволяют техники тест-дизайна.
Тест-дизайн — этап тестирования ПО, на котором проектируются и создаются тестовые случаи (тест-кейсы). Они соответствуют определённым ранее критериям качества и целям тестирования.
Важно, что критерии качества и цели тестирования должны быть определены до начала написания тест-кейсов. От этих критериев и целей зависит, какими будут тест-кейсы, для каких модулей они будут описаны в первую очередь, проверка каких функций будет приоритетной. Когда мы пишем тест-кейсы, одна из основных задач — создать оптимальное тестовое покрытие функциональности, то есть не допустить «слепых зон» в системе, которые не покрываются проверками.
Задачи тест-дизайна на проекте:
● максимально покрыть функциональность тестами;
● обнаружить серьёзные баги;
● сократить количество тестов, исключив непродуктивные;
● не пропустить важные тесты.

Техник тест-дизайна довольно много. Мы сосредоточимся на самых популярных:
1. Классы эквивалентности.
2. Анализ граничных значений.
3. Переход состояний.
4. Попарное тестирование.
5. Таблицы принятия решений.
Эквивалентное разделение  и анализ граничных значений направлены на сокращение количества необходимых тестовых сценариев. В связи с этим при разработке тестов для тестирования методом черного ящика эти техники применяются чаще всего.

Классы эквивалентности.
Класс эквивалентности — набор данных, которые обрабатываются одинаковым образом и приводят к одному результату.
Эквивалентное разделение подразумевает разбиение тестовых данных на классы по какому-то признаку. Этот метод имеет смысл только в том случае, если компоненты чем-то похожи и могут войти в общую группу.
Если мы выбираем в качестве техники тест-дизайна эквивалентное разделение, это означает, что мы будем тестировать только несколько значений из каждого класса элементов. Помните, что это не гарантирует отсутствия ошибок в остальных значениях, не охваченных тестами. Мы лишь предполагаем, что использование нескольких элементов из каждой группы будет достаточно показательным.
Эквивалентное разделение — хорошее решение для случаев, когда вы имеете дело с большим объемом входящих данных или множеством одинаковых вариантов ввода. В противном случае, возможно, имеет смысл более тщательно охватить продукт тестами.

Пример эквивалентного разделения.
Допустим, есть интернет-магазин, который предлагает разные тарифы на доставку в зависимости от стоимости корзины.
Например:
1. Стоимость доставки для заказов на сумму менее 1000 руб составляет 200 руб.
2. Стоимость доставки для заказов на сумму более 1000 руб составляет 100 руб.
3. При заказе от 3000 руб долларов доставка бесплатна.
У нас есть следующие ценовые категории для работы:
1. от 1 руб до 1000 руб.
2. от 1000 руб до 3000 руб.
3. 3000 руб и выше.
При использовании техники эквивалентного разделения мы получаем три набора данных для тестирования:
      1. От 1 до 1000:
       допустимые значения: любая цена в диапазоне от 1 до 999,99
       недопустимые значения: любая цена ниже 1 или выше 999,99
      2. От 1000 до 3000:
       допустимые значения: любая цена в диапазоне от 1000 до 2999,99
       недопустимые значения: любая цена ниже 1000 или выше 2999,99
      3. 3000 и выше:
        допустимые значения: любая цена выше 2999,99;
        недопустимые значения: любая цена ниже 3000.
Таким образом, мы можем выбрать несколько чисел из каждого диапазона цен и предположить, что остальные числа из этих диапазонов будут давать такие же результаты.
Аналогичные действия проводятся и с другими данными, которые используются системой, например, со временем.
В примере выше мы рассмотрели данные, которые можно расположить на числовой прямой — классы эквивалентности этих данных будут линейными. Их можно разбить на диапазоны с точными границами начала и конца.
Нелинейные классы эквивалентности — это набор неупорядоченных данных. У них нет границ, они являются частью множества данных. Пример — расширения файлов, операционные системы, группы пользователей с различными правами (пользователь, модератор, администратор) и так далее. В этом случае можно выделить только два класса эквивалентности:
● валидный — соответствует требованиям,
● невалидный — не соответствует требованиям или обрабатывается системой отличным от валидного класса образом.
Рассмотрим другой пример. Тестируется система таможенного контроля, которая обрабатывает паспортные данные выезжающего за границу и определяет, есть ли он в базе лиц, для которых выезд ограничен (например, из-за финансового долга).
Здесь есть два класса эквивалентности:
1. Валидный — данных пересекающего границу нет в базе лиц, которым выезд запрещён. Выезд разрешён.
2. Невалидный — данные пересекающего границу внесены в базу. Выезд запрещён.
Кроме чисел, на классы эквивалентности можно разбить:
● символы — они могут быть валидными (@ в адресе электронной почты) и невалидными (?, %,*);
● длину строки — например, валидный класс от 1 до 30 знаков, невалидный — всё остальное (меньше 1 и больше 30);
● объём памяти, который необходим приложению для стабильной работы;
● разрешение экрана — всё, что меньше или больше заявленных требований к разрешению экрана, будет относиться к невалидным классам;
● версии операционных систем, библиотек — также определяются согласно требованиям. Например, приложение должно работать на ОС Windows 7, но поддержка Windows Nt уже не требуется.
● объём передаваемых данных — по требованиям. Например, если мощности сервера не позволяют обработать объём данных больше определённого значения.
Классы эквивалентности — одна из основных техник тест-дизайна. Именно с ней тестировщики и тест-дизайнеры работают чаще всего. Она сокращает число тестов (можно выбрать только несколько значений из класса эквивалентности), но к использованию нужно подходить внимательно: если неверно выделить класс эквивалентности, можно получить некорректные результаты тестирования и пропустить ошибку.

Анализ граничных значений.
Анализ граничных значений в чем-то похож на эквивалентное разделение. Можно даже сказать, что оно лежит в основе анализа граничных значений. Но есть некоторые отличия.
При анализе граничных значений мы тоже группируем данные по линейным эквивалентным классам, но проверяем не значения из определенного класса, а граничные значения — те, которые находятся на «границах» классов. 
Граничные значения обязательно используются при написании тестов, так как именно на границе классов эквивалентности чаще всего и обнаруживаются ошибки. Например, если в требованиях указано, что пользователь сайта должен быть старше 16 лет, тестировщику следует уточнить у аналитика, входит ли значение «16 лет» в валидный класс эквивалентности. А затем — проверить, действительно ли это реализовано в приложении. Может оказаться, что разработчик понял требования иначе и указал в коде, что сайтом могут пользоваться лица с 17 лет (>16 вместо >=16).
Алгоритм определения граничных значений:
1. Выделить классы эквивалентности.
2. Определить граничные значения этих классов.
3. Определить, к какому классу будет относиться каждая граница.
4. Для каждой границы провести тесты: проверить значения до границы, на ней и сразу после неё.
Возьмем предыдущий сценарий с различными тарифами на доставку. У нас те же данные, но другой подход к их использованию. Предполагая, что ошибки наиболее вероятны на границах диапазонов, мы тестируем только «граничные» числа:
      1. От 1 до 1000:
        допустимые граничные значения: 1,00, 1,01, 999,99
        недопустимые граничные значения: 0,99, 1000,00, 1000,01
      2. От 1000 до 3000:
        допустимые граничные значения: 1000,00, 1000,01, 2999,99;
        недопустимые граничные значения: 999,99, 3000,00;
      3. 3000 и выше:
        допустимые граничные значения: 3000,00, 3000,01;
        недопустимые граничные значения: 2999,99.
На основании этих данных можно проводить тестирование.

Переход состояний.
Диаграмма перехода состояний визуализирует состояния программы в разные периоды времени и на разных этапах использования. Визуальную информацию воспринимать проще, чем текст. Таким образом, техника перехода состояний позволяет быстрее получить максимальное тестовое покрытие. 
Этот метод эффективен при создании наборов тестов для систем со множеством вариаций состояний. Он вам пригодится для тестирования последовательности событий с конечным числом входных параметров.
Прежде чем рассматривать эту технику, познакомимся с основными понятиями, которые используются при составлении диаграмм переходов и состояний.
      Точка входа — старт работы системы или приложения.
      Переход (transition) — переход системы из одного состояния в другое. Происходит в результате действий пользователя или при определённых условиях.
      Событие (event) — действие пользователя, которые он выполнил для перевода системы в другое состояние. Или действия самой системы, меняющие её состояние.
      Действие (action) — реакция приложения на действия пользователя или самой системы (на событие).
      Условия перехода (transition conditions) — условия, которые необходимы для перехода системы в другое состояние. Например, изменение даты для начисления процентов на вклад.
      Состояние (state) — состояние системы до или после перехода в результате действий пользователя или при определённых условиях.
      Точка выхода — успешное окончание полного цикла работы приложения, то есть выполнение всех переходов и состояний.
      Роли пользователей (actors) — пользователи, которые могут по-разному влиять на систему в зависимости от уровня прав доступа (зарегистрированный пользователь, менеджер, администратор).


!!!!! Далее дописано в папке ДП на компе.!!!!
